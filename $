import math
from datetime import datetime
from models.coordinate_model import Coordinate
import random
from geopy.geocoders import Nominatim
from typing import Type, Self, Typle
# from global-land-mask import globe

def is_in_ocean(latitude: float, longitude: float) -> bool:
    """ Check whether if the given point is in the ocean or on land

    Parameters:
        latitude (float): Latitude of the point to check
        longitude (float): Longitude of the point to check

    Returns:
        (bool): True iff the given point is in the ocean

    Example:
    ```python
    assert(is_in_ocean(43, -23.5))
    assert(not(is_in_ocean(59, 80)))
    ```
    """
    # return globe.is_ocean(latitude, longitude)
    geolocator = Nominatim(user_agent="is_in_ocean")
    location = geolocator.reverse((latitude, longitude), exacly_one=True)
    if not(location):
        return False

def _move_point(
    latitude: float,
    longitude: float,
    delta_latitude: float,
    delta_longitude: float
) -> Tuple[float, float]:
    """ Moves a point from the given coordinate and following the given
    deplacement, keeping the coordinates value in their possible interval.

    Parameters:
        latitude (float): Latitude of the point to move
        longitude (float): Longitude of the point to move
        delta_latitude (float): Wanted deplacement for the latitude
        delta_longitude (float): Wanted deplacement for the longitude

    Returns:
        (Tuple[float, float]): New latitude and longitude after the deplacement
    """
    new_latitude = latitude + delta_latitude
    new_latitude = (new_latitude + 90) % 180 - 90
    new_longitude = longitude + delta_longitude
    new_longitude = (new_longitude + 180) % 360 - 180
    return new_latitude, new_longitude


class CoordinateTracker:
    """ Moves a point randomly

    Attributes:
        ip (str): Ip of the tracker
        latitude (float): Current latitude of the point
        longitude (float): Current longitude of the point
        speed (float): Speed of the point
        direction (float): Angle of deplacement of the point
        angular_speed (float): Absolute value of the maximal angular speed of
        the point


    def __init__(self, ip, initial_latitude, initial_longitude, initial_speed, initial_direction, angular_speed, can_swim):
        # Initialisation des coordonnées et de la direction
        self.ip = ip
        self.latitude = initial_latitude
        self.longitude = initial_longitude
        self.speed = initial_speed
        self.direction = initial_direction
        self.angular_speed = angular_speed
        self.can_swim = can_swim

    def _rotate(self: Self):
        self.direction += random.uniform(-self.angular_speed, self.angular_speed)

    def _generate_speed(
        self: Self,
        direction_in_radians: float,
        time_elapsed: float
    ) -> Tuple[float, float]:
        distance = self.speed * time_elapsed
        delta_latitude = distance * math.cos(direction_in_radians)
        delta_longitude = distance * math.sin(direction_in_radians)
        return delta_latitude, delta_longitude

    def update_position(self: Self, time_elapsed: float):
        self._rotate()
        delta_latitude, delta_longitude = self._generate_speed(
            direction_in_radians = math.radians(self.direction),
            time_elapsed = time_elapsed
        )
        new_latitude, new_longitude = _move_point(
            latitude = self.latitude,
            longitude = self.longitude,
            delta_latitude = delta_latitude,
            delta_longitude = delta_longitude
        )
        if self.can_swim or not(is_in_ocean(new_latitude, new_longitude)):
            self.latitude = new_latitude
            self.longitude = new_longitude
        else:
            self._bring_back_to_continent(
                wanted_delta_latitude = delta_latitude,
                wanted_delta_longitude = delta_longitude
            )

    def _bring_back_to_continent(
        self: Self,
        wanted_delta_latitude: float,
        wanted_delta_longitude: float
    ):
        position_if_reverse = _move_point(
            latitude = self.latitude,
            longitude = self.longitude,
            delta_latitude = -wanted_delta_latitude,
            delta_longitude = -wanted_delta_longitude
        )
        if not(is_in_ocean(*position_if_reverse)):
            self.latitude, self.longitude = position_if_reverse
        else:
            # The point does not move
            pass
        
        
    def get_coordinates(self):
        # Renvoie les coordonnées actuelles
        return Coordinate(
            ip = self.ip,
            time = datetime.now(),
            latitude = self.latitude,
            longitude = self.longitude
        )


###########################

#Fonction de génération de coordonnées aléatoires
def generate_gps_coordinates():
    latitude = random.uniform(-90,90)
    longitude = random.uniform(-180,180)
    return {'latitude':latitude, 'longitude':longitude}
    
if __name__ == '__main__':

    # Exemple d'utilisation
    initial_coordinates = generate_gps_coordinates()
    initial_speed = 10.0
    initial_direction = 15.0

    tracker = CoordinateTracker(0, initial_coordinates['latitude'], initial_coordinates['longitude'], initial_speed, initial_direction)

    # Mis à jour de la position après une certaine période de temps
    time_elapsed = 1.0
    tracker.update_position(time_elapsed)

    # Obtenez les nouvelles coordonnées
    new_coordinates = tracker.get_coordinates()
    print("Nouvelles coordonnées:", new_coordinates)
